package main

import (
	"math"
	"testing"
)

var gamma = []float64{
	2.3254348370739963835386613898e+01,
	2.991153837155317076427529816e+03,
	-4.561154336726758060575129109e+00,
	7.719403468842639065959210984e-01,
	1.6111876618855418534325755566e+05,
	1.8706575145216421164173224946e+00,
	3.4082787447257502836734201635e+01,
	1.579733951448952054898583387e+00,
	9.3834586598354592860187267089e-01,
	-2.093995902923148389186189429e-05,
}

var vfgamma = [][2]float64{
	{math.Inf(1), math.Inf(1)},
	{math.Inf(-1), math.NaN()},
	{0, math.Inf(1)},
	{math.Copysign(0, -1), math.Inf(-1)},
	{math.NaN(), math.NaN()},
	{-1, math.NaN()},
	{-2, math.NaN()},
	{-3, math.NaN()},
	{-1e16, math.NaN()},
	{-1e300, math.NaN()},
	{1.7e308, math.Inf(1)},

	// Test inputs inspired by Python test suite.
	// Outputs computed at high precision by PARI/GP.
	// If recomputing table entries, be careful to use
	// high-precision (%.1000g) formatting of the float64 inputs.
	// For example, -2.0000000000000004 is the float64 with exact value
	// -2.00000000000000044408920985626161695, and
	// gamma(-2.0000000000000004) = -1249999999999999.5386078562728167651513, while
	// gamma(-2.00000000000000044408920985626161695) = -1125899906826907.2044875028130093136826.
	// Thus the table lists -1.1258999068426235e+15 as the answer.
	{0.5, 1.772453850905516},
	{1.5, 0.886226925452758},
	{2.5, 1.329340388179137},
	{3.5, 3.3233509704478426},
	{-0.5, -3.544907701811032},
	{-1.5, 2.363271801207355},
	{-2.5, -0.9453087204829419},
	{-3.5, 0.2700882058522691},
	{0.1, 9.51350769866873},
	{0.01, 99.4325851191506},
	{1e-08, 9.999999942278434e+07},
	{1e-16, 1e+16},
	{0.001, 999.4237724845955},
	{1e-16, 1e+16},
	{1e-308, 1e+308},
	{5.6e-309, 1.7857142857142864e+308},
	{5.5e-309, math.Inf(1)},
	{1e-309, math.Inf(1)},
	{1e-323, math.Inf(1)},
	{5e-324, math.Inf(1)},
	{-0.1, -10.686287021193193},
	{-0.01, -100.58719796441078},
	{-1e-08, -1.0000000057721567e+08},
	{-1e-16, -1e+16},
	{-0.001, -1000.5782056293586},
	{-1e-16, -1e+16},
	{-1e-308, -1e+308},
	{-5.6e-309, -1.7857142857142864e+308},
	{-5.5e-309, math.Inf(-1)},
	{-1e-309, math.Inf(-1)},
	{-1e-323, math.Inf(-1)},
	{-5e-324, math.Inf(-1)},
	{-0.9999999999999999, -9.007199254740992e+15},
	{-1.0000000000000002, 4.5035996273704955e+15},
	{-1.9999999999999998, 2.2517998136852485e+15},
	{-2.0000000000000004, -1.1258999068426235e+15},
	{-100.00000000000001, -7.540083334883109e-145},
	{-99.99999999999999, 7.540083334884096e-145},
	{17, 2.0922789888e+13},
	{171, 7.257415615307999e+306},
	{171.6, 1.5858969096672565e+308},
	{171.624, 1.7942117599248104e+308},
	{171.625, math.Inf(1)},
	{172, math.Inf(1)},
	{2000, math.Inf(1)},
	{-100.5, -3.3536908198076787e-159},
	{-160.5, -5.255546447007829e-286},
	{-170.5, -3.3127395215386074e-308},
	{-171.5, 1.9316265431712e-310},
	{-176.5, -1.196e-321},
	{-177.5, 5e-324},
	{-178.5, math.Copysign(0, -1)},
	{-179.5, 0},
	{-201.0001, 0},
	{-202.9999, math.Copysign(0, -1)},
	{-1000.5, math.Copysign(0, -1)},
	{-1.0000000003e+09, math.Copysign(0, -1)},
	{-4.5035996273704955e+15, 0},
	{-63.349078729022985, 4.177797167776188e-88},
	{-127.45117632943295, 1.183111089623681e-214},
}

func TestGamma2(t *testing.T) {
	for i := 0; i < len(vf); i++ {
		if f := Gamma(vf[i]); !close(gamma[i], f) {
			t.Errorf("Gamma(%g) = %g, want %g", vf[i], f, gamma[i])
		}
	}
	for _, g := range vfgamma {
		f := Gamma(g[0])
		var ok bool
		if math.IsNaN(g[1]) || math.IsInf(g[1], 0) || g[1] == 0 || f == 0 {
			ok = alike(g[1], f)
		} else if g[0] > -50 && g[0] <= 171 {
			ok = veryclose(g[1], f)
		} else {
			ok = close(g[1], f)
		}
		if !ok {
			t.Errorf("Gamma(%g) = %g, want %g", g[0], f, g[1])
		}
	}
}

func TestGamma(t *testing.T) {
	// Test cases with expected results
	tests := []struct {
		input    float64
		expected float64
	}{
		{1.00000, 1.00000},
		{1.01000, 0.99433},
		{1.02000, 0.98884},
		{1.03000, 0.98355},
		{1.04000, 0.97844},
		{1.05000, 0.97350},
		{1.06000, 0.96874},
		{1.07000, 0.96415},
		{1.08000, 0.95973},
		{1.09000, 0.95546},
		{1.10000, 0.95135},
		{1.11000, 0.94740},
		{1.12000, 0.94359},
		{1.13000, 0.93993},
		{1.14000, 0.93642},
		{1.15000, 0.93304},
		{1.16000, 0.92980},
		{1.17000, 0.92670},
		{1.18000, 0.92373},
		{1.19000, 0.92089},
		{1.20000, 0.91817},
		{1.21000, 0.91558},
		{1.22000, 0.91311},
		{1.23000, 0.91075},
		{1.24000, 0.90852},
		{1.25000, 0.90640},
		{1.25000, 0.90640},
		{1.26000, 0.90440},
		{1.27000, 0.90250},
		{1.28000, 0.90072},
		{1.29000, 0.89904},
		{1.30000, 0.89747},
		{1.31000, 0.89600},
		{1.32000, 0.89464},
		{1.33000, 0.89338},
		{1.34000, 0.89222},
		{1.35000, 0.89115},
		{1.36000, 0.89018},
		{1.37000, 0.88931},
		{1.38000, 0.88854},
		{1.39000, 0.88785},
		{1.40000, 0.88726},
		{1.41000, 0.88676},
		{1.42000, 0.88636},
		{1.43000, 0.88604},
		{1.44000, 0.88581},
		{1.45000, 0.88566},
		{1.46000, 0.88560},
		{1.47000, 0.88563},
		{1.48000, 0.88575},
		{1.49000, 0.88595},
		{1.50000, 0.88623},
		{1.50000, 0.88623},
		{1.51000, 0.88659},
		{1.52000, 0.88704},
		{1.53000, 0.88757},
		{1.54000, 0.88818},
		{1.55000, 0.88887},
		{1.56000, 0.88964},
		{1.57000, 0.89049},
		{1.58000, 0.89142},
		{1.59000, 0.89243},
		{1.60000, 0.89352},
		{1.61000, 0.89468},
		{1.62000, 0.89592},
		{1.63000, 0.89724},
		{1.64000, 0.89864},
		{1.65000, 0.90012},
		{1.66000, 0.90167},
		{1.67000, 0.90330},
		{1.68000, 0.90500},
		{1.69000, 0.90678},
		{1.70000, 0.90864},
		{1.71000, 0.91057},
		{1.72000, 0.91258},
		{1.73000, 0.91467},
		{1.74000, 0.91683},
		{1.75000, 0.91906},
		{1.75000, 0.91906},
		{1.76000, 0.92137},
		{1.77000, 0.92376},
		{1.78000, 0.92623},
		{1.79000, 0.92877},
		{1.80000, 0.93138},
		{1.81000, 0.93408},
		{1.82000, 0.93685},
		{1.83000, 0.93969},
		{1.84000, 0.94260},
		{1.85000, 0.94561},
		{1.86000, 0.94869},
		{1.87000, 0.95184},
		{1.88000, 0.95507},
		{1.89000, 0.95838},
		{1.90000, 0.96177},
		{1.91000, 0.96520},
		{1.92000, 0.96877},
		{1.93000, 0.97240},
		{1.94000, 0.97610},
		{1.95000, 0.97988},
		{1.96000, 0.98374},
		{1.97000, 0.98768},
		{1.98000, 0.99171},
		{1.99000, 0.99581},
	}

	tolerance := 1e-4
	// Run tests
	for _, test := range tests {
		result := Gamma(test.input)
		if math.Abs(result-test.expected) > tolerance {
			t.Errorf("For input %f, expected %f, but got %f", test.input, test.expected, result)
		}
	}
}
